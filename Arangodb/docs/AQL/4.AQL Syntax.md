## AQLè¯­æ³•
æŸ¥è¯¢ç±»å‹ï¼Œç©ºç™½ï¼Œæ³¨é‡Šï¼Œå…³é”®å­—å’ŒAQLè¯­è¨€ä¸­çš„åç§°è§£é‡Š

### æŸ¥è¯¢ç±»å‹
ä¸€ä¸ªAQLçš„æŸ¥è¯¢å¿…é¡»è¦ä¹ˆè¿”å›ä¸€ä¸ªç»“æœï¼ˆä½¿ç”¨RETURNå…³é”®å­—ï¼‰ï¼Œè¦ä¹ˆæ‰§è¡Œä¸€ä¸ªæ•°æ®ä¿®æ”¹æ“ä½œï¼ˆä½¿ç”¨INSERTï¼ŒUPDATEï¼ŒREPLACEï¼ŒREMOVEæˆ–UPSERTå…³é”®å­—ï¼‰ã€‚å¦‚æœAQLè§£æå™¨åœ¨ä¸€ä¸ªæŸ¥è¯¢ä¸­æ£€æµ‹åˆ°å¤šä¸ªæ•°æ®ä¿®æ”¹æ“ä½œï¼Œæˆ–è€…å®ƒæ— æ³•ç¡®å®šæŸ¥è¯¢æ˜¯æ•°æ®æ£€ç´¢è¿˜æ˜¯ä¿®æ”¹æ“ä½œï¼Œå°†è¿”å›ä¸€ä¸ªé”™è¯¯ã€‚

AQLåªå…è®¸ä¸€ä¸ªæŸ¥è¯¢åœ¨å•ä¸ªæŸ¥è¯¢å­—ç¬¦ä¸²ä¸­ï¼Œå› æ­¤ï¼Œä¸æ”¯æŒåƒSQLé‚£æ ·ä½¿ç”¨åˆ†å·;æ¥åˆ†éš”å¤šä¸ªæŸ¥è¯¢è¯­å¥æ˜¯ä¸å…è®¸çš„ã€‚

è¿™æ„å‘³ç€æ¯æ¬¡åªèƒ½æ‰§è¡Œä¸€ä¸ªæŸ¥è¯¢æ“ä½œï¼Œå¦‚æœæœ‰å¤šä¸ªæŸ¥è¯¢éœ€è¦æ‰§è¡Œï¼Œæ‚¨éœ€è¦å¯¹æ¯ä¸ªæŸ¥è¯¢å•ç‹¬è°ƒç”¨æ‰§è¡Œæ–¹æ³•æˆ–è€…åœ¨åº”ç”¨å±‚è¿›è¡Œé€»è¾‘å¤„ç†ã€‚
```js
const db = require('@arangodb').db;

// å•ç‹¬æ‰§è¡Œä¸¤ä¸ªæŸ¥è¯¢
let query1Result = db._query('FOR u IN users RETURN u');
let query2Result = db._query('FOR p IN posts RETURN p');
```
è€Œä¸æ˜¯åƒåœ¨SQLä¸­é‚£æ ·å†™æˆä¸€ä¸ªå­—ç¬¦ä¸²ï¼š
```sql
-- SQLé£æ ¼çš„ç¤ºä¾‹ï¼ˆåœ¨AQLä¸­æ— æ•ˆï¼‰
SELECT * FROM users; SELECT * FROM posts;
```

### ç©ºç™½
ç©ºç™½ï¼ˆç©ºç™½ï¼Œå›è½¦ï¼Œæ¢è¡Œï¼Œåˆ¶è¡¨ç¬¦ï¼‰å¯ä»¥åœ¨æŸ¥è¯¢æ–‡æœ¬ä¸­ç”¨æ¥å¢åŠ å¯è¯»æ€§ã€‚Tokenså¿…é¡»ç”¨ä»»æ„æ•°é‡çš„ç©ºç™½éš”å¼€ã€‚åœ¨å­—ç¬¦ä¸²æˆ–åç§°ä¸­ï¼Œå¦‚æœå¸Œæœ›ä¿ç•™ç©ºç™½ï¼Œå¿…é¡»ç”¨å¼•å·å°†å…¶åŒ…å«åœ¨å†…ã€‚

### æ³¨é‡Š
æ³¨é‡Šå¯ä»¥åµŒå…¥åˆ°æŸ¥è¯¢ä¸­çš„ä»»ä½•ä½ç½®ã€‚AQLè§£æå™¨å°†å¿½ç•¥åŒ…å«åœ¨æ³¨é‡Šä¸­çš„æ–‡æœ¬ã€‚

å¤šè¡Œæ³¨é‡Šä¸èƒ½åµŒå¥—ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåç»­æ³¨é‡Šçš„å¼€å§‹å¿…é¡»åœ¨æ³¨é‡Šçš„ç»“æŸä¹‹åï¼Œå¦åˆ™å°†è¢«å¿½ç•¥ã€‚

AQLæ”¯æŒä¸¤ç§ç±»å‹çš„æ³¨é‡Šï¼š

å•è¡Œæ³¨é‡Šï¼šåŒæ–œæ å¼€å¤´ï¼Œç»“æŸäºè¡Œçš„æœ«å°¾æˆ–æŸ¥è¯¢å­—ç¬¦ä¸²çš„æœ«å°¾ï¼ˆä»¥å…ˆåˆ°è€…ä¸ºå‡†ï¼‰

å¤šè¡Œæ³¨é‡Šï¼šè¿™äº›ä»¥æ–œæ /å’Œæ˜Ÿå·å¼€å§‹ï¼Œä»¥æ˜Ÿå·å’Œæ–œæ /ç»“æŸã€‚å®ƒä»¬å¯ä»¥è·¨å¤šè¡Œï¼Œå¯ä»¥åŒ…å«ä»»æ„æ•°é‡çš„è¡Œã€‚
```AQL
// å•è¡Œæ³¨é‡Š

/* å¤šè¡Œ
   æ³¨é‡Š */
```

### å…³é”®å­—
åœ¨é¡¶å±‚ï¼ŒAQLæä¾›äº†ä»¥ä¸‹é«˜çº§æ“ä½œï¼š

|æ“ä½œ|æè¿°|
|---|---|
| FOR | æ•°ç»„è¿­ä»£ |
| RETURN | ç»“æœè¿”å› |
| FILTER |éè§†å›¾çš„ç»“æœç­›é€‰ |
| SEARCH | è§†å›¾çš„ç»“æœç­›é€‰ |
| SORT | ç»“æœæ’åº |
| LIMIT | ç»“æœåˆ‡ç‰‡|
| LET | å˜é‡èµ‹å€¼ |
| COLLECT | ç»“æœèšåˆ|
| WINDOW | èšåˆç›¸å…³è¡Œ |
| INSERT | æ’å…¥æ–°æ–‡æ¡£ |
| UPDATE | (éƒ¨åˆ†)æ›´æ–°å·²æœ‰çš„æ–‡æ¡£ |
| REPLACE | æ›¿æ¢å·²æœ‰çš„æ–‡æ¡£ |
| REMOVE | ç§»é™¤å·²æœ‰çš„æ–‡æ¡£ |
| UPSERT | æ’å…¥æ–°æ–‡æ¡£ï¼Œå¦‚æœå­˜åœ¨åˆ™æ›´æ–° |
| WITH | é›†åˆå£°æ˜ |

æ¯ä¸ªæ“ä½œå¯ä»¥ä»¥å…³é”®å­—å½¢å¼åœ¨æŸ¥è¯¢ä¸­ä½¿ç”¨ã€‚ä¸€ä¸ªAQLæŸ¥è¯¢é€šå¸¸ç”±å¤šä¸ªè¿™äº›æ“ä½œç»„æˆã€‚

ä¸€ä¸ªAQLæŸ¥è¯¢å¯èƒ½å¦‚ä¸‹æ‰€ç¤ºï¼š
```
FOR u IN users
  FILTER u.type == "newbie" && u.active == true
  RETURN u.name
```
åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæœ¯è¯­FORï¼ŒFILTERå’ŒRETURNæ˜¯æ ¹æ®å®ƒä»¬çš„åå­—æ¥ç¡®å®šå®ƒä»¬çš„é«˜çº§æ“ä½œã€‚è¿™äº›æœ¯è¯­ä¹Ÿæ˜¯å…³é”®å­—ï¼Œåœ¨è¯­è¨€ä¸­å…·æœ‰ç‰¹æ®Šå«ä¹‰ã€‚

ä¾‹å¦‚ï¼ŒæŸ¥è¯¢è§£æå™¨å°†æ ¹æ®å…³é”®å­—åå­—æ¥ç¡®å®šå®ƒä»¬çš„é«˜çº§æ“ä½œã€‚è¿™æ„å‘³ç€å…³é”®å­—åªèƒ½åœ¨ç‰¹å®šä½ç½®ä½¿ç”¨ï¼Œå¹¶ä¸”æ‰€æœ‰å…³é”®å­—çš„å•è¯éƒ½ä½œä¸ºä¿ç•™å­—ï¼Œä¸èƒ½ç”¨åœ¨å…¶ä»–åœ°æ–¹ã€‚

ä¾‹å¦‚ï¼Œæ— å¼•å·å­—ç¬¦ä¸²ï¼ˆæ ‡è¯†ç¬¦ï¼‰çš„å…³é”®å­—ä¸èƒ½ç”¨ä½œé›†åˆæˆ–å±æ€§åç§°ã€‚å¦‚æœä½ éœ€è¦åœ¨é›†åˆæˆ–è€…å±æ€§ä¸­ä½¿ç”¨ä¸å…³é”®å­—ç›¸åŒçš„åç§°ï¼Œåˆ™éœ€è¦åœ¨æŸ¥è¯¢ä¸­å¯¹é›†åˆæˆ–å±æ€§åè¿›è¡Œå¼•å·å¤„ç†ã€‚å‚è§[Names](#names)

Keywords are case-insensitive, meaning they can be specified in lower, upper, or mixed case in queries. In this documentation, all keywords are written in upper case to make them distinguishable from other query parts.

There are a few more keywords in addition to the higher-level operation keywords. Additional keywords may be added in future versions of ArangoDB. The complete list of keywords is currently:

AGGREGATE
ALL
ALL_SHORTEST_PATHS
AND
ANY
ASC
COLLECT
DESC
DISTINCT
FALSE
FILTER
FOR
GRAPH
IN
INBOUND
INSERT
INTO
K_PATHS
K_SHORTEST_PATHS
LET
LIKE
LIMIT
NONE
NOT
NULL
OR
OUTBOUND
REMOVE
REPLACE
RETURN
SHORTEST_PATH
SORT
TRUE
UPDATE
UPSERT
WINDOW
WITH
On top of that, there are a few words used in language constructs which are not reserved keywords. You can use them as collection or attribute names without having to quote them. The query parser can identify them as keyword-like based on the context:

KEEP â€“ COLLECT operation variant
COUNT (WITH COUNT INTO) â€“ COLLECT operation variant
OPTIONS â€“ FOR / Graph Traversal / SEARCH / COLLECT / INSERT / UPDATE / REPLACE / UPSERT / REMOVE operation
PRUNE â€“ Graph Traversal, FOR operation variant
SEARCH â€“ SEARCH operation
TO â€“ Shortest Path / All Shortest Paths / k Shortest Paths / k Paths graph traversal
Last but not least, there are special variables which are available in certain contexts. Unlike keywords, they are case-sensitive:

CURRENT â€“ available in array inline expressions
NEW â€“ available after INSERT / UPDATE / REPLACE / UPSERT operation
OLD â€“ available after UPDATE / REPLACE / UPSERT / REMOVE operation
If you define a variable with the same name in the same scope, then its value will be and remain at what you set it to. Hence you need to avoid these names for your own variables if you want to access the special variable values.

<a id="names"></a>
Names 
In general, names are used to identify the following things in AQL queries:

collections
attributes
variables
functions
Names in AQL are always case-sensitive. The maximum supported length for collection/View names is 256 bytes. Variable names can be longer, but are discouraged.

Keywords should not be used as names. If you want to use a reserved keyword as name anyway, the name must be enclosed in backticks or forward ticks. This is referred to as quoting.

FOR doc IN `filter`
  RETURN doc.`sort`
Due to the backticks, filter and sort are interpreted as names and not as keywords here.

You can also use forward ticks:

FOR f IN Â´filterÂ´
  RETURN f.Â´sortÂ´
Instead of ticks, you may use the bracket notation for the attribute access:

FOR f IN `filter`
  RETURN f["sort"]
sort is a string literal in quote marks in this alternative and does thus not conflict with the reserved keyword.

Quoting with ticks is also required if certain characters such as hyphen minus (-) are contained in a name, namely if they are used for operators in AQL:

LET `my-var` = 42
Collection names 
You can typically use collection names in queries as they are. If a collection happens to have the same name as a keyword, the name must be enclosed in backticks or forward ticks.

Quoting with ticks is also required if special characters such as hyphen minus (-) are contained in a collection name:

FOR doc IN `my-coll`
  RETURN doc
The collection my-coll has a dash in its name, but - is an arithmetic operator for subtraction in AQL. The backticks quote the collection name to refer to the collection correctly.

If you use extended collection and View names (--database.extended-names startup option), they may contain spaces, or non-ASCII characters such as Japanese or Arabic letters, emojis, letters with accentuation, and other UTF-8 characters. Quoting is required in these cases, too:

FOR doc IN Â´ğŸ¥‘~ĞºĞ¾Ğ»ĞµĞºÑ†Ñ–Ñ =)Â´
  RETURN doc
The collection name contains characters that are allowed using the extended naming constraints and is quoted with forward ticks.

Note that quoting the name with " or ' is not possible for collections as they cannot be string literals in quote marks.

For information about the naming constraints for collections, see Collection names.

Attribute names 
When referring to attributes of documents from a collection, the fully qualified attribute name must be used. This is because multiple collections with ambiguous attribute names may be used in a query. To avoid any ambiguity, it is not allowed to refer to an unqualified attribute name.

Also see the naming restrictions for Attribute names.

FOR u IN users
  FOR f IN friends
    FILTER u.active == true && f.active == true && u.id == f.userId
    RETURN u.name
In the above example, the attribute names active, name, id, and userId are qualified using the collection names they belong to (u and f respectively).

Variable names 
AQL allows you to assign values to additional variables in a query. All variables that are assigned a value must have a name that is unique within the context of the query.

FOR u IN users
  LET friends = u.friends
  RETURN { "name" : u.name, "friends" : friends }
In the above query, users is a collection name, and both u and friends are variable names. This is because the FOR and LET operations need target variables to store their intermediate results.

Variable names should be different from the names of any collection name used in the same query to avoid shadowing, which can render a collection with the same name inaccessible in the query after the variable assignment:

LET users = []
FOR u IN users // iterates over the "users" variable, not the "users" collection
  RETURN u
Allowed characters in variable names are the letters a to z (both in lower and upper case), the numbers 0 to 9, the underscore (_) symbol and the dollar ($) sign. A variable name must not start with a number. If a variable name starts with one or multiple underscore characters, the underscore(s) must be followed by least one letter (a-z or A-Z). The dollar sign can only be used as the very first character in a variable name and must be followed by a letter.