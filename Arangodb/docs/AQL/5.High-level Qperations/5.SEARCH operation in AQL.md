[SEARCH operation in AQL](https://docs.arangodb.com/3.11/aql/high-level-operations/search/)

# SHEARCH操作
SEARCH操作筛选视图，底层索引加速查询速度

SEARCH操作保证将视图索引用于高效的执行计划。如果对“视图”使用FILTER关键字，则不会使用索引，并且过滤是作为后处理步骤执行的。

从概念上讲，视图只是另一个文档数据源，类似于数组或文档/边缘集合，您可以使用AQL中的FOR操作对其进行迭代：
```
FOR doc IN viewName
  RETURN doc
```

可选的SEARCH操作提供了以下功能：

- 基于AQL布尔表达式和函数过滤文档
- 利用快速索引匹配不同集合中的文档
- 根据文档与搜索条件的匹配程度对结果集进行排序

有关如何设置视图，请参阅[arangsearch Views](https://docs.arangodb.com/3.11/index-and-search/arangosearch/arangosearch-views-reference/)和[search alias Views](https://docs.arangodb.com/3.11/index-and-search/arangosearch/search-alias-views-reference/)

## 语法

SEARCH 关键字后面跟随的是 ArangoSearch 过滤表达式，该表达式主要由对 ArangoSearch AQL 函数的调用组成。
```
FOR doc IN viewName
  SEARCH expression
  OPTIONS { … }
  ...
```

## 使用

SEARCH 语句与 FILTER 语句不同，它被视为 FOR 操作的一部分，而非独立的语句。因此，SEARCH 不能自由地放置在查询中的任何位置，也不能在同一 FOR 循环体内出现多次。FOR ... IN 后面必须跟一个视图（View）的名字，而不是集合（collection）。紧接着 FOR ... IN 的必须是 SEARCH 操作，不允许在此位置之前放置诸如 FILTER、COLLECT 等操作。然而，在 SEARCH 之后可以执行其他操作，比如使用 SORT 对搜索结果按由视图计算出的排名值进行排序。

表达式必须是一个 ArangoSearch 表达式。ArangoSearch 的全部功能通过特殊的 ArangoSearch 函数在搜索和排序阶段得以利用和展现。此外，还支持常见的 AQL 运算符。

需要注意的是，内联表达式以及其他一些特性并不被 SEARCH 支持。如果表达式无效，服务器会抛出查询错误。

在搜索表达式之后，可以选择性地跟随 OPTIONS 关键字以及一个对象来设置搜索选项。

## 逻辑操作
逻辑运算符或布尔运算符允许组合多个搜索条件。

- AND, && (与)
- OR, || (或)
- NOT, ! (非)

需要考虑运算符优先级，并且可以使用括号进行控制。

思考以下表达式：
```
doc.value < 0 OR doc.value > 5 AND doc.value IN [-10, 10]
```
AND的优先级高于OR。该表达式等效于：
```
doc.value < 0 OR (doc.value > 5 AND doc.value IN [-10, 10])
```
此条件表达是:


- value 小于0
- 值大于5，但仅当它是10（或-10，但这永远无法实现）

括号可按如下方式用于将AND条件应用于两个OR条件：
```
(doc.value < 0 OR doc.value > 5) AND doc.value IN [-10, 10]
```
此条件表达是:


- 值小于0，但仅当它为-10时
- 值大于5，但仅当它为10时

## 比较运算符
- == (equal)
- <= (less than or equal)
- >= (greater than or equal)
- < (less than)
- > (greater than)
- != (unequal)
- IN (contained in array or range), also NOT IN
- LIKE (equal with wildcards), also NOT LIKE

另请参阅[IN_RANGE（）函数](https://docs.arangodb.com/3.11/aql/functions/arangosearch/#in_range)，以获取用于范围搜索的<、<=、>、>=运算符组合的替代方法。
```
FOR doc IN viewName
  SEARCH ANALYZER(doc.text == "quick" OR doc.text == "brown", "text_en")
  // -- or --
  SEARCH ANALYZER(doc.text IN ["quick", "brown"], "text_en")
  RETURN doc
```
ArangoSearch不考虑字符的字母顺序，即针对视图的SEARCH操作中的范围查询将不遵循定义的Analyzer区域设置（排序规则Analyzer除外）或服务器语言（启动选项-默认语言）的语言规则！另请参阅已知问题。

## 数组比较运算符
数组比较运算符支持：
```
LET tokens = TOKENS("some input", "text_en")                 // ["some", "input"]
FOR doc IN myView SEARCH tokens  ALL IN doc.text RETURN doc // dynamic conjunction
FOR doc IN myView SEARCH tokens  ANY IN doc.text RETURN doc // dynamic disjunction
FOR doc IN myView SEARCH tokens NONE IN doc.text RETURN doc // dynamic negation
FOR doc IN myView SEARCH tokens  ALL >  doc.text RETURN doc // dynamic conjunction with comparison
FOR doc IN myView SEARCH tokens  ANY <= doc.text RETURN doc // dynamic disjunction with comparison
FOR doc IN myView SEARCH tokens NONE <  doc.text RETURN doc // dynamic negation with comparison
FOR doc IN myView SEARCH tokens AT LEAST (1+1) IN doc.text RETURN doc // dynamically test for a subset of elements
```

以下运算符在SEARCH表达式中等效：

- ALL IN, ALL ==, NONE !=, NONE NOT IN
- ANY IN, ANY ==
- NONE IN, NONE ==, ALL !=, ALL NOT IN
- ALL >, NONE <=
- ALL >=, NONE <
- ALL <, NONE >=
- ALL <=, NONE >
- AT LEAST (...) IN, AT LEAST (...) ==
- AT LEAST (1) IN, ANY IN

The stored attribute referenced on the right side of the operator is like a single, primitive value. In case of multiple tokens, it is like having multiple such values as opposed to an array of values, even if the actual document attribute is an array. IN and == as part of array comparison operators are treated the same in SEARCH expressions for ease of use. The behavior is different outside of SEARCH, where IN needs to be followed by an array.

Question mark operator 
You can use the Question mark operator to perform Nested searches with ArangoSearch (Enterprise Edition only):

FOR doc IN myView
  SEARCH doc.dimensions[? FILTER CURRENT.type == "height" AND CURRENT.value > 40]
  RETURN doc
It allows you to match nested objects in arrays that satisfy multiple conditions each, and optionally define how often these conditions should be fulfilled for the entire array. You need to configure the View specifically for this type of search using the nested property in arangosearch Views or in the definition of Inverted Indexes that you can add to search-alias Views.

Handling of non-indexed fields 
Document attributes which are not configured to be indexed by a View are treated by SEARCH as non-existent. This affects tests against the documents emitted from the View only.

For example, given a collection myCol with the following documents:

{ "someAttr": "One", "anotherAttr": "One" }
{ "someAttr": "Two", "anotherAttr": "Two" }
… with an arangosearch View where someAttr is indexed by the following View myView:

{
  "type": "arangosearch",
  "links": {
    "myCol": {
      "fields": {
        "someAttr": {}
      }
    }
  }
}
… a search on someAttr yields the following result:

FOR doc IN myView
  SEARCH doc.someAttr == "One"
  RETURN doc
[ { "someAttr": "One", "anotherAttr": "One" } ]
A search on anotherAttr yields an empty result because only someAttr is indexed by the View:

FOR doc IN myView
  SEARCH doc.anotherAttr == "One"
  RETURN doc
[]
You can use the special includeAllFields arangosearch View property to index all (sub-)attributes of the source documents if desired.

SEARCH with SORT 
The documents emitted from a View can be sorted by attribute values with the standard SORT() operation, using one or multiple attributes, in ascending or descending order (or a mix thereof).

FOR doc IN viewName
  SORT doc.text, doc.value DESC
  RETURN doc
If the (left-most) fields and their sorting directions match up with the primary sort order definition of the View then the SORT operation is optimized away.

Apart from simple sorting, it is possible to sort the matched View documents by relevance score (or a combination of score and attribute values if desired). The document search via the SEARCH keyword and the sorting via the ArangoSearch Scoring Functions, namely BM25() and TFIDF(), are closely intertwined. The query given in the SEARCH expression is not only used to filter documents, but also is used with the scoring functions to decide which document matches the query best. Other documents in the View also affect this decision.

Therefore the ArangoSearch scoring functions can work only on documents emitted from a View, as both the corresponding SEARCH expression and the View itself are consulted in order to sort the results.

FOR doc IN viewName
  SEARCH ...
  SORT BM25(doc) DESC
  RETURN doc
The BOOST() function can be used to fine-tune the resulting ranking by weighing sub-expressions in SEARCH differently.

If there is no SEARCH operation prior to calls to scoring functions or if the search expression does not filter out documents (e.g. SEARCH true) then a score of 0 will be returned for all documents.

Search Options 
The SEARCH operation accepts an options object with the following attributes:

collections (array, optional): array of strings with collection names to restrict the search to certain source collections
conditionOptimization (string, optional): controls how search criteria get optimized. Possible values:
"auto" (default): convert conditions to disjunctive normal form (DNF) and apply optimizations. Removes redundant or overlapping conditions, but can take quite some time even for a low number of nested conditions.
"none": search the index without optimizing the conditions.
countApproximate (string, optional): controls how the total count of rows is calculated if the fullCount option is enabled for a query or when a COLLECT WITH COUNT clause is executed
"exact" (default): rows are actually enumerated for a precise count.
"cost": a cost-based approximation is used. Does not enumerate rows and returns an approximate result with O(1) complexity. Gives a precise result if the SEARCH condition is empty or if it contains a single term query only (e.g. SEARCH doc.field == "value"), the usual eventual consistency of Views aside.
Examples

Given a View with three linked collections coll1, coll2 and coll3 it is possible to return documents from the first two collections only and ignore the third using the collections option:

FOR doc IN viewName
  SEARCH true OPTIONS { collections: ["coll1", "coll2"] }
  RETURN doc
The search expression true matches all View documents. You can use any valid expression here while limiting the scope to the chosen source collections.